# 小组介绍

## 控制平面验证
控制平面用于控制和管理所有网络协议的运行

控制平面提供了数据平面数据处理转发前所必须的各种网络信息和转发查询表项

## 数据平面验证
交换机的基本任务是处理和转发各个不同端口上给类型的数据, 如L2/L3/ACL等各种具体的数据处理转发过程, 这些都属于数据平面

# A General Approach to Network Configuration Analysis
由UCLA/USC以及微软的研究人员于NSDI2015提出

## 会议介绍
NSDI全称USENIX网络系统设计与实现会议, 是该领域最重要国际学术会议之一, 与SIGCOMM相比

有两个特点

1. 更偏重网络系统, 如目前流行的分布式大数据处理系统Spark发表于NSDI 2012
2. 更偏重设计实现, 所有文章都有完整的实现

NSDI 2015特点

强调了工业界的实际需求和论文技术的系统级实现, 所以这次还有谷歌/微软/Facebook/VMware等公司发表了些实践文章, 对真实运行的网络系统进行了阐述

这篇文章是在议会的Correctness部分, 同时这部分还有上节课同学讲的Checking Beliefs in Dynamic Networks

## 背景
网络通过一系列路由器和交换机转发数据包.  现在的网络通常是对设备进行配置来设定控制层.  然而配置文件中的描述语言层次较低, 都到了接口级, 而且网络中涉及到多种多样的协议如OSPF/BGP, 使用这些来进行信息的内部交换, 因此还少不了各种协议之间的交互 .

配置网络是艰巨的, 因为策略要求特别复杂,因为以上的几个原因. 错误非常常见.

## 举个例子
考虑图2的网络N, 它有两个相邻的AS. P是一个大型网络供应商AS, C是拥有两个目的地前缀的客户AS. 路由N2直接连接到具有10.0.0.0/24前缀的内部私有网络. 为了让这个网络仅对于C是可用的, 因此需要作出相应的配置如图2下文字.

通过这样的设置可以防止P和n4(及后面的主机)访问10.0.0.0/24, 且当有非法访问时管理员能够察觉.

1.n2中的PLC定义缺少了3.3.3.0/24, 因此n2将丢掉所有相关的包并且对于这个前缀没有任何连接. 应用配置是很难发现这个错误, 因为通过n1可以连接到. 只有当n1 c2或链路c2 n1都失败时才会发现到3.3.3.0/24的连接全部丢失. 缺乏了容错的能力以及负载均衡的能力

2.n2和n3将重新分配连接静态网络, n1将从两个相邻的节点得到到10.0.0.0/24的且成本相同的路径. 这就造成了默认情况就是多路径路由; n1将通过两个相邻节点向10.0.0.0/24发送数据包. 但是只有通过n2发送的数据包能到达目的地, 因为n3将丢弃这样的数据包. 这就造成了交通链路会经常间歇性重连. 

现有的方法不能在应用错误的网络配置之前发现这两种错误. 数据层分析可以发现数据包到不到达的问题但是无法发现第一种错误. 而静态分析方法(针对特定协议中的特定错误)则发现不了第二种错误, 因为这需要OSPF/连接路由/静态路由,以及通过这些的相互作用的精确模型. 

Batfish因为通过了1静态分析配置和2从配置中导出数据层的模型, 从而能发现提前发现这两种错误


## 以前的方法
这种静态分析方法可以在应用新配置之前发现错误, 对不同环境做出不同的分析.

然而真实网络是复杂的且有很多的交互, 现有的分析工具是对特定的配置开发特定的模型来应对这种复杂性. 例如RCC方法是生成配置的规范化表示, FIREMAN生成规则图来表示每个ACL并以此进行分析. 这种选择性聚焦确实可以用来分析网络配置, 但是也制约了分析的范围. 此外, 由于配置的其他很多方面都没有进行分析, 运营商很难去评估出发生的错误是否最终影响网络中数据包的转发

因为数据平面反应了所有配置的综合影响, 因此这种方法可以精确的检测出导致转发发生问题的任何配置错误. 数据平面的语义易于理解, 在各种逻辑结构中都可以有效地编码.

但是在发生错误转发之前数据平面快照并不能主动的防治错误的发生. 一旦出现问题, 管理员仍然需要在本地配置中定位错误. 这通常是非常困难的, 因为并不一定是最近更改的配置导致发生了错误, 而错误的配置也可能在很久之后才会造成影响. 


## 本文提出的方法--Batfish
### 可以做到
通过从数据平面实际推导和分析, 可以做到:

1. 在应用配置之前就发现错误

2. 检查大量的转发属性, 且可以产生违反这些属性的实际数据包

### 遇到的挑战
令作者们感觉棘手的是怎么将配置文件中的低级语言转换成高级的声明性语言. 控制层和最后的数据层模型的声明性质能提供一个简单的关系本体, 管理员可以用这个来了解错误的来源. 声明性语言显然比命令式代码更客观清晰.

使用LogiQL语言来描述各种协议.   

产生控制平面模型

第一个这么做的方案

## Batfish

### 在Batfish中实现的静态网络配置分析方法

图3展示了其工作流程的四个阶段

#### 从配置到数据层
前两个阶段将给定的网络配置转换成了具体的数据层. 

#### 阶段一
阶段1, 通过一个生成器将网络配置以及拓扑结构生成控制层的逻辑模型.

使用了之前提及的LogiQL语言,  生成了每个节点的RIB表

因为配置文件跟拓扑结构是确定下来不会变动的, 因此仅生成一个控制平面模型

#### 阶段二
阶段2, 加入了环境作为附加输入, 因此这能进行不同情况的假设分析.

输入的环境信息包括了网络中每个链路的上行/下行状态以及路由宣告等,   描述具体链路的通断情况

通过数据层生成器来将控制层模型和环境生成数据层模型. 

通过RIB表能得到每个节点的FIB表

所得到的数据层模型包含了各个路由器的转发行为(如丢弃还是转发给相邻节点), 

这里因为环境包含了很多的情况, 因此会产生不同情况下对应的不同的数据平面模型.

与以前的静态分析技术不同, Batfish的前两个阶段分析了网络配置中与数据层相关的方方面面, 因此生成的数据层能准确的表达配置/拓扑结构和环境引起的转发行为.


#### 从数据层到配置错误
Batfish剩下的两个阶段是用来识别和定位配置错误. 

#### 阶段三
阶段3  分析一个或多个数据层来验证正确属性. 

得益于LogiQL的能力.这一环节是通过检查表示为关系公式的属性进行.  

将数据平面关系以及正确的属性通过分析器转换, 然后验证属性或者提供一个或多个反例.

除了用户指定的属性Batfish还能检查传统的可验证属性如是否有环路等. Batfish前两个阶段是与属性无关的所以可以生成需要用的数据层, 检查数据层上任意的属性而不用重新创建. 

#### 阶段四
阶段4  帮助管理员了解错误, 以便于修复网络配置. 通过在数据层模型上,用网络逻辑模拟反例数据包来进行. 

在这个阶段会产生各种中间结果,使用的LogiQL能反应出他们的关系.有些能直接向用户提供错误来源的信息如导致分组被丢弃的ACL的特定行.  

对于之前举例的网络的第二个错误, Batfish能检测出多路径不一致的错误. 


## 评估
在两个使用不同设计的大型网络中使用, Net1和Net2. 

先分析Net1和Net2最新的网络配置. 正在稳定的工作但是存在管理员没有意识到的错误.

对于Net1, 使用了21个路由组成3层网络,3边界路由5核心路由和13个分布路由, 路由使用OSPF作为内部链接. 边界路由和分布路由则使用BGP. 他们设计的想法是每个部门的AS都希望与Net1核心网络有冗余的对等连接, 且每个部门拥有自己独立的地址空间. 供应商AS接受任意的数据包, 而部门AS则被配置为接受每个网络但是丢弃所有没分配到他们拥有的地址空间的数据包. 

Net2使用VLAN将网络分成两大层. 总共17个路由器3个是核心路由其他链接卫星校园.所有路由器运行OSPF实现内部链接.Net2没有使用BGP.


表1总结了发生的错误以及对应的数量. 网络中缺乏容错能力, 网络拓扑建模缺乏精确性. 


#### 分析 
Batfish去尝模拟配置中影响转发的所有方面, 不会产生假真或假伪.

但是还会有以下三种问题:

2. 与所有的验证方案一样, Batfish所有分析的基础都是路由器根据配置正常运行, 如果是路由器的硬件或者软件(BGP实现)发生了错误, 则这种错误无法发现. 

1. Batfish分析的是给定环境下的网络, 因此对于未提供的环境Batfish可能会无法检测某些错误.   因为要分析各种协议以及环境中能出现的各种情况, 导致计算速度很慢, 后面的ARC针对Batfish的这一缺陷进行设计.

3. Batfish可能会遇到配置中当前仍未实现的功能, 有可能影响本地路由的选择. Batfish使用数据层作为中间表示, 因此可以通过向控制层模型添加逻辑规则来影响转发从未将当前未实现的功能加入模型中. 

对于以前的工具来说, 对新功能重新建模和分析将是非常困难的.
