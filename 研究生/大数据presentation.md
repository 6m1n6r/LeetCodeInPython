# 整体的消费模型

用一组(xi,ti)的列表来表示用户的消费序列。其中xi是物品，ti是时间。
使用一下高级过程来建模：

## 时间模型
用来描述到达间隔时间（inter-arrival times）.

到达间隔时间delta i+1 = ti+1 - ti, 是从随机过程中产生.

## 新模型
用来描述重复消费以及新的消费.

给出delta 1....delta i, 来确定xi是新的消费还是重复消费

## 选择模型
来描述商品特性.

如果xi是新的, 从一些分布中抽出(draw from some distribution), 否则则从历史分布中抽出(draw from the history following some distribution). 分布取决于到达间隔时间(inter-arrival times).

# 时间模型

通过对到达时间间隔(即用户消费间的时间)进行建模.

最简单的到达时间间隔模型允许IID从一个到达时间分布来选择. 然而图四显示, 我们的一些数据集的到达间隔并不是独立分布的:

图4: 消费序列中下一个时间间隔小于20分钟的可能性给出了一个最后k个小于20分钟的间隔与k之间的函数, 从Youtube数据中得出的. 数据和模型显示出了连续型消费的活动状态. 边际概率是间隔小于20分钟的概率, 是与k无关的(相当于k=0的时候)

当用户在实际的消费中如果是一段持续时间的服务, 用户的行为会与这段时间间隔的不同. 例如, 对于音乐的消费, 用户会在一段时间内听好几首歌, 在服务休息之前. 

持续活动中的行为很简单, 描述了持续型的消费. 因此, 出了考虑了IID到达时间间隔分布的自然选择外, 我们还考虑了到达时间间隔的半马尔科夫模型, 即用户从两个状态中的转变:持续活动中和持续活动的间隔, 它们每个都有自己的到达时间间隔分布. 这可能是到达之间最简单的依赖关系, 用一个位的形式来确定状态. 我们表明, 从一个单一状态的IID模型变化到双状态持续模型的可能性增大, 大到足以证明复杂性轻微的增加. 每个状态的到达时间间隔分布更简单和自然. 

## 半马尔科夫模型

我们的半马尔科夫模型描述了用户消费的活动以及非活动的状态. 以下的生成模型描述了这行为:

1. 画出当前持续活动中K到D1的消费
2. 从D2中画出k个会话间隙
3. 画出s到D3的会话间隙

对于未知的D1 D2和D3, 这是一个明确时间的隐藏的马尔科夫模型. 在分析相关数据后, 我们根据以下来求出分布.

### 会话长度分布D1

D1中持续消费的物品数k服从遵循一个幂指数

### 会话内间隙分布D2

D2中的一个会话内的间隙G2服从双Pareto分布

### 会话间隙分布D3

D3中的一个会话间隙G3遵循一个简单的幂指数分布


图5展示了LASTFM数据集的这三个分布. 这些分布的尾部有些差异(D2的头部也是), 是因为缺少了这部分点的数据.

图6展示了由从LASTFM实际数据以及模型模拟出来的到达时间间隔总分布. 模型模拟情况与实际数据匹配度高.


我们还将我们的半马尔科夫模型与几个常见的到达间隔模型进行比较, 其中一个样本就是IID. 对于考虑的每个IID的到达分布, 表4展示了该模型与我们的半马尔科夫模型的似然性. 首先计算每个IID分布的最大似然估计量, 然后取数据中每个到达时间间隔的似然率的平均值进行计算. 从表中可以看出半马尔科夫模型比常见IID的到达间隔模型好. 

## 优化模型参数

为了简化参数估计, 我们让一段会话包含了所有物品的消费, 且没有中间最少B分钟的休息时间. 从数据中分析, 我们发现B=20的情况适用于音乐和视频的数据集, B=60适合点击和点进去的数据集. 做出这个假设之后, 每个会话中商品数会遵循具有最大值B指数的指数分布, 会话间隔时间则遵循具有最小值B指数的指数分布, 我们还知道会话中到达时间的经验分布. 进行分解之后, 我们将数据用对数表示, 使用非线性求解器来求最优化的概率密度函数. 虽然有更复杂的最大似然最大化程序来估算这些参数, 但是我们发现简单的曲线拟合其实在实践中更好的发挥作用. 

# 新模型

接下来, 我们将讨论用户何时进行重复消费的预测问题. 我们把这种预测作为一个监督学习问题来处理, 并且使用了用户重复消费的倾向性/用户目前为止消费的物品数量(不论最近几次消费是不是重复消费)/上次消费依赖的时间 作为特征值. 用户是否进行重复消费(或进行重复消费的概率)是因变量. 

我们在scikit-learn库中选择了几种学习算法进行测试, 发现逻辑回归表现最好. 表5列出了对每个数据集进行逻辑回归的错误率. 我们发现在LASTFM和LASTFM ARTISTS数据集上能获得最好的结果, 他们两者都包含了大量的重复消费. 

